

"""     problem 1        """


def arithmetic_series_sum(n):
    return (n * (n + 1)) / 2


def sum_of_multiples(a, b, bound):
    a_multiples = int(bound / a)
    b_multiples = int(bound / b)
    a_times_b_multiples = int(bound / (a * b))

    a_multiples_sum = a * arithmetic_series_sum(a_multiples)
    b_multiples_sum = b * arithmetic_series_sum(b_multiples)
    a_times_b_multiples_sum = a * b * arithmetic_series_sum(a_times_b_multiples)

    return int(a_multiples_sum + b_multiples_sum - a_times_b_multiples_sum)


print(sum_of_multiples(3, 5, 999))









"""     problem 2        """


def sum_of_even_fibonacci_numbers(bound):
    sum_of_even_numbers = 0
    fn_minus_2 = 0
    fn_minus_1 = 1

    while fn_minus_2 < bound:
        fn = fn_minus_1 + fn_minus_2
        fn_minus_2 = fn_minus_1
        fn_minus_1 = fn

        if fn_minus_2 % 2 == 0:
            sum_of_even_numbers += fn_minus_2

    return sum_of_even_numbers


print(sum_of_even_fibonacci_numbers(4000000))









"""     problem 3        """


def find_max_prime_factor(num):
    divisors = {1}
    current_candidate_prime = 2
    current_unknown_factors_product = num

    while current_unknown_factors_product > 1:
        if current_unknown_factors_product % current_candidate_prime == 0:
            current_unknown_factors_product /= current_candidate_prime
            divisors.add(current_candidate_prime)

        elif current_candidate_prime > 2:
            current_candidate_prime += 2

        else:
            current_candidate_prime += 1

    return max(divisors)


print(find_max_prime_factor(600851475143))









"""     problem 4        """


def is_palindrome(n):
    num = str(n)
    num_length = len(num)
    mid = int(num_length / 2)

    first_half = num[:mid]
    second_half = num[mid:]
    second_half = second_half[::-1]

    if mid != num_length / 2:
        second_half = second_half[:-1]

    return first_half == second_half


def find_max_palindrome_product(lower_bound, higher_bound):
    palindromes = []

    current_number = higher_bound

    while current_number >= lower_bound:
        current_product = current_number * current_number
        smallest_current_product = current_number * lower_bound

        while current_product >= smallest_current_product:
            if is_palindrome(current_product):
                palindromes.append(current_product)
            current_product -= current_number

        current_number -= 1

    return max(palindromes)


print(find_max_palindrome_product(100, 999))









"""     problem 5        """


def min_product(bound):
    product = 1
    upper_bound = bound + 1
    factors = []

    for j in range(2, upper_bound):
        for i in factors:
            if j % i == 0:
                j /= i

        factors.append(j)
        product *= j

    return int(product)


print(min_product(20))









"""     problem 6        """


def sum_of_squares(n):
    return int((n * (n + 1)) * (2 * n + 1) / 6)


def square_of_sum(n):
    return int(((n * (n + 1)) / 2)) ** 2


print(abs(sum_of_squares(100) - square_of_sum(100)))









"""     problem 7        """


def is_prime(num, primes_list):
    for prime in primes_list:
        if num % prime == 0:
            return False
    return True


def find_prime(index):
    primes = [2]
    cur = 3

    while len(primes) < index:
        if is_prime(cur, primes):
            primes.append(cur)

        cur += 2

    return primes[-1]


print(find_prime(10001))










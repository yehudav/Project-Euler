

"""     problem 1        """


def arithmetic_series_sum(n):
    return (n * (n + 1)) / 2


def sum_of_multiples(a, b, bound):
    a_multiples = int(bound / a)
    b_multiples = int(bound / b)
    a_times_b_multiples = int(bound / (a * b))

    a_multiples_sum = a * arithmetic_series_sum(a_multiples)
    b_multiples_sum = b * arithmetic_series_sum(b_multiples)
    a_times_b_multiples_sum = a * b * arithmetic_series_sum(a_times_b_multiples)

    return int(a_multiples_sum + b_multiples_sum - a_times_b_multiples_sum)


print(sum_of_multiples(3, 5, 999))









"""     problem 2        """


def sum_of_even_fibonacci_numbers(bound):
    sum_of_even_numbers = 0
    fn_minus_2 = 0
    fn_minus_1 = 1

    while fn_minus_2 < bound:
        fn = fn_minus_1 + fn_minus_2
        fn_minus_2 = fn_minus_1
        fn_minus_1 = fn

        if fn_minus_2 % 2 == 0:
            sum_of_even_numbers += fn_minus_2

    return sum_of_even_numbers


print(sum_of_even_fibonacci_numbers(4000000))









"""     problem 3        """


def find_max_prime_factor(num):
    divisors = {1}
    current_candidate_prime = 2
    current_unknown_factors_product = num

    while current_unknown_factors_product > 1:
        if current_unknown_factors_product % current_candidate_prime == 0:
            current_unknown_factors_product /= current_candidate_prime
            divisors.add(current_candidate_prime)

        elif current_candidate_prime > 2:
            current_candidate_prime += 2

        else:
            current_candidate_prime += 1

    return max(divisors)


print(find_max_prime_factor(600851475143))









"""     problem 4        """


def is_palindrome(n):
    num = str(n)
    num_length = len(num)
    mid = int(num_length / 2)

    first_half = num[:mid]
    second_half = num[mid:]
    second_half = second_half[::-1]

    if mid != num_length / 2:
        second_half = second_half[:-1]

    return first_half == second_half


def find_max_palindrome_product(lower_bound, higher_bound):
    palindromes = []

    current_number = higher_bound

    while current_number >= lower_bound:
        current_product = current_number * current_number
        smallest_current_product = current_number * lower_bound

        while current_product >= smallest_current_product:
            if is_palindrome(current_product):
                palindromes.append(current_product)
            current_product -= current_number

        current_number -= 1

    return max(palindromes)


print(find_max_palindrome_product(100, 999))









"""     problem 5        """


def min_product(bound):
    product = 1
    upper_bound = bound + 1
    factors = []

    for j in range(2, upper_bound):
        for i in factors:
            if j % i == 0:
                j /= i

        factors.append(j)
        product *= j

    return int(product)


print(min_product(20))









"""     problem 6        """


def sum_of_squares(n):
    return int((n * (n + 1)) * (2 * n + 1) / 6)


def square_of_sum(n):
    return int(((n * (n + 1)) / 2)) ** 2


print(abs(sum_of_squares(100) - square_of_sum(100)))









"""     problem 7        """


def is_prime(num, primes_list):
    for prime in primes_list:
        if num % prime == 0:
            return False
    return True


def find_prime(index):
    primes = [2]
    cur = 3

    while len(primes) < index:
        if is_prime(cur, primes):
            primes.append(cur)

        cur += 2

    return primes[-1]


print(find_prime(10001))









"""     problem 8        """


def max_adjacent_digits_product(number, adjacent_digits_num):
    str_of_num = str(number)
    max_product = 0
    start_value = 1

    while len(str_of_num) > adjacent_digits_num:
        product = start_value
        for digit in range(adjacent_digits_num):
            product *= int(str_of_num[digit])

        if product > max_product:
            max_product = product

        str_of_num = str_of_num[1:]

    return max_product


given_number = 731671765313306249192251196744265747423553491949349698352031277450632623957831801698480186947885184385861560789112949
495459501737958331952853208805511125406987471585238630507156932909632952274430435576689664895044524452316173185640309871112172238311
362229893423380308135336276614282806444486645238749303589072962904915604407723907138105158593079608667017242712188399879790879227492
190169972088809377665727333001053367881220235421809751254540594752243525849077116705560136048395864467063244157221553975369781797784
617406495514929086256932197846862248283972241375657056057490261407972968652414535100474821663704844031998900088952434506585412275886
668811642717147992444292823086346567481391912316282458617866458359124566529476545682848912883142607690042242190226710556263211111093
705442175069416589604080719840385096245544436298123098787992724428490918884580156166097919133875499200524063689912560717606058861164
6710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

print(max_adjacent_digits_product(given_number, 13))









"""     problem 9        """


for a in range(1, 1001):
    for b in range(1, 1001):
        if ((a * b) / 1000) == (a + b - 500) and a < b:
            print(a, b, 1000 - a - b)
            print(a * b * (1000 - a - b))
            exit(0)













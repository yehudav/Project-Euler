

"""     problem 1        """


def arithmetic_series_sum(n):
    return (n * (n + 1)) / 2


def sum_of_multiples(a, b, bound):
    a_multiples = int(bound / a)
    b_multiples = int(bound / b)
    a_times_b_multiples = int(bound / (a * b))

    a_multiples_sum = a * arithmetic_series_sum(a_multiples)
    b_multiples_sum = b * arithmetic_series_sum(b_multiples)
    a_times_b_multiples_sum = a * b * arithmetic_series_sum(a_times_b_multiples)

    return int(a_multiples_sum + b_multiples_sum - a_times_b_multiples_sum)


print(sum_of_multiples(3, 5, 999))









"""     problem 2        """


def sum_of_even_fibonacci_numbers(bound):
    sum_of_even_numbers = 0
    fn_minus_2 = 0
    fn_minus_1 = 1

    while fn_minus_2 < bound:
        fn = fn_minus_1 + fn_minus_2
        fn_minus_2 = fn_minus_1
        fn_minus_1 = fn

        if fn_minus_2 % 2 == 0:
            sum_of_even_numbers += fn_minus_2

    return sum_of_even_numbers


print(sum_of_even_fibonacci_numbers(4000000))









"""     problem 3        """


def find_max_prime_factor(num):
    divisors = {1}
    current_candidate_prime = 2
    current_unknown_factors_product = num

    while current_unknown_factors_product > 1:
        if current_unknown_factors_product % current_candidate_prime == 0:
            current_unknown_factors_product /= current_candidate_prime
            divisors.add(current_candidate_prime)

        elif current_candidate_prime > 2:
            current_candidate_prime += 2

        else:
            current_candidate_prime += 1

    return max(divisors)


print(find_max_prime_factor(600851475143))









"""     problem 4        """


def is_palindrome(n):
    num = str(n)
    num_length = len(num)
    mid = int(num_length / 2)

    first_half = num[:mid]
    second_half = num[mid:]
    second_half = second_half[::-1]

    if mid != num_length / 2:
        second_half = second_half[:-1]

    return first_half == second_half


def find_max_palindrome_product(lower_bound, higher_bound):
    palindromes = []

    current_number = higher_bound

    while current_number >= lower_bound:
        current_product = current_number * current_number
        smallest_current_product = current_number * lower_bound

        while current_product >= smallest_current_product:
            if is_palindrome(current_product):
                palindromes.append(current_product)
            current_product -= current_number

        current_number -= 1

    return max(palindromes)


print(find_max_palindrome_product(100, 999))









"""     problem 5        """


def min_product(bound):
    product = 1
    upper_bound = bound + 1
    factors = []

    for j in range(2, upper_bound):
        for i in factors:
            if j % i == 0:
                j /= i

        factors.append(j)
        product *= j

    return int(product)


print(min_product(20))









"""     problem 6        """


def sum_of_squares(n):
    return int((n * (n + 1)) * (2 * n + 1) / 6)


def square_of_sum(n):
    return int(((n * (n + 1)) / 2)) ** 2


print(abs(sum_of_squares(100) - square_of_sum(100)))









"""     problem 7        """


def is_prime(num, primes_list):
    for prime in primes_list:
        if num % prime == 0:
            return False
    return True


def find_prime(index):
    primes = [2]
    cur = 3

    while len(primes) < index:
        if is_prime(cur, primes):
            primes.append(cur)

        cur += 2

    return primes[-1]


print(find_prime(10001))









"""     problem 8        """


def max_adjacent_digits_product(number, adjacent_digits_num):
    str_of_num = str(number)
    max_product = 0

    while len(str_of_num) > adjacent_digits_num:
        product = 1
        for digit in range(13):
            product *= int(str_of_num[digit])

        if product > max_product:
            max_product = product
        str_of_num = str_of_num[1:]

    return max_product


given_number = 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

print(max_adjacent_digits_product(given_number, 13))












"""     problem 1        """


def arithmetic_series_sum(n):
    return (n * (n + 1)) / 2


def sum_of_multiples(a, b, bound):
    a_multiples = int(bound / a)
    b_multiples = int(bound / b)
    a_times_b_multiples = int(bound / (a * b))

    a_multiples_sum = a * arithmetic_series_sum(a_multiples)
    b_multiples_sum = b * arithmetic_series_sum(b_multiples)
    a_times_b_multiples_sum = a * b * arithmetic_series_sum(a_times_b_multiples)

    return int(a_multiples_sum + b_multiples_sum - a_times_b_multiples_sum)


print(sum_of_multiples(3, 5, 999))









"""     problem 2        """


def sum_of_even_fibonacci_numbers(bound):
    sum_of_even_numbers = 0
    fn_minus_2 = 0
    fn_minus_1 = 1

    while fn_minus_2 < bound:
        fn = fn_minus_1 + fn_minus_2
        fn_minus_2 = fn_minus_1
        fn_minus_1 = fn

        if fn_minus_2 % 2 == 0:
            sum_of_even_numbers += fn_minus_2

    return sum_of_even_numbers


print(sum_of_even_fibonacci_numbers(4000000))









"""     problem 3        """


def find_max_prime_factor(num):
    divisors = {1}
    current_candidate_prime = 2
    current_unknown_factors_product = num

    while current_unknown_factors_product > 1:
        if current_unknown_factors_product % current_candidate_prime == 0:
            current_unknown_factors_product /= current_candidate_prime
            divisors.add(current_candidate_prime)

        elif current_candidate_prime > 2:
            current_candidate_prime += 2

        else:
            current_candidate_prime += 1

    return max(divisors)


print(find_max_prime_factor(600851475143))









"""     problem 4        """


def is_palindrome(n):
    num = str(n)
    num_length = len(num)
    mid = int(num_length / 2)

    first_half = num[:mid]
    second_half = num[mid:]
    second_half = second_half[::-1]

    if mid != num_length / 2:
        second_half = second_half[:-1]

    return first_half == second_half


def find_max_palindrome_product(lower_bound, higher_bound):
    palindromes = []

    current_number = higher_bound

    while current_number >= lower_bound:
        current_product = current_number * current_number
        smallest_current_product = current_number * lower_bound

        while current_product >= smallest_current_product:
            if is_palindrome(current_product):
                palindromes.append(current_product)
            current_product -= current_number

        current_number -= 1

    return max(palindromes)


print(find_max_palindrome_product(100, 999))









"""     problem 5        """


def min_product(bound):
    product = 1
    upper_bound = bound + 1
    factors = []

    for j in range(2, upper_bound):
        for i in factors:
            if j % i == 0:
                j /= i

        factors.append(j)
        product *= j

    return int(product)


print(min_product(20))









"""     problem 6        """


def sum_of_squares(n):
    return int((n * (n + 1)) * (2 * n + 1) / 6)


def square_of_sum(n):
    return int(((n * (n + 1)) / 2)) ** 2


print(abs(sum_of_squares(100) - square_of_sum(100)))









"""     problem 7        """


def is_prime(num, primes_list):
    for prime in primes_list:
        if num % prime == 0:
            return False
    return True


def find_prime(index):
    primes = [2]
    cur = 3

    while len(primes) < index:
        if is_prime(cur, primes):
            primes.append(cur)

        cur += 2

    return primes[-1]


print(find_prime(10001))









"""     problem 8        """


def max_adjacent_digits_product(number, adjacent_digits_num):
    str_of_num = str(number)
    max_product = 0
    start_value = 1

    while len(str_of_num) > adjacent_digits_num:
        product = start_value
        for digit in range(adjacent_digits_num):
            product *= int(str_of_num[digit])

        if product > max_product:
            max_product = product

        str_of_num = str_of_num[1:]

    return max_product


given_number = 731671765313306249192251196744265747423553491949349698352031277450632623957831801698480186947885184385861560789112949
495459501737958331952853208805511125406987471585238630507156932909632952274430435576689664895044524452316173185640309871112172238311
362229893423380308135336276614282806444486645238749303589072962904915604407723907138105158593079608667017242712188399879790879227492
190169972088809377665727333001053367881220235421809751254540594752243525849077116705560136048395864467063244157221553975369781797784
617406495514929086256932197846862248283972241375657056057490261407972968652414535100474821663704844031998900088952434506585412275886
668811642717147992444292823086346567481391912316282458617866458359124566529476545682848912883142607690042242190226710556263211111093
705442175069416589604080719840385096245544436298123098787992724428490918884580156166097919133875499200524063689912560717606058861164
6710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

print(max_adjacent_digits_product(given_number, 13))









"""     problem 9        """


for a in range(1, 1001):
    for b in range(1, 1001):
        if ((a * b) / 1000) == (a + b - 500) and a < b:
            print(a, b, 1000 - a - b)
            print(a * b * (1000 - a - b))
            exit(0)









"""     problem 10        """


import math


def remove_zeros(list):
    new_list = []

    for num in list:
        if num:
            new_list.append(num)

    return new_list


def sieve_of_eratosthenes(bound, return_primes_only):
    numbers = [0, 0]
    max_factor = int(math.sqrt(bound))

    for k in range(2, bound):
        numbers.append(k)

    for i in range(2, max_factor + 1):
        if numbers[i]:
            j = i * i
            while j < bound:
                numbers[j] = 0
                j += i

    if return_primes_only:
        return remove_zeros(numbers)

    return numbers


print(sum(sieve_of_eratosthenes(2000000, False)))









"""     problem 11        """


def max_of_three(a, b, c):
    return max(a, max(b, c))


def max_product(line, adjacent_digits_num):
    max_product_of_line = 0

    while len(line) >= adjacent_digits_num:
        current_product = 1

        for i in range(adjacent_digits_num):
            current_product *= int(line[i])

        max_product_of_line = max(current_product, max_product_of_line)

        line = line[1:]

    return max_product_of_line


def create_matrix_from_file(path):
    file = open(path)
    matrix = []

    for line in file:
        str_numbers = line.split(" ")
        matrix.append(str_numbers)

    return matrix


def matrix_rows_max_product(m, adjacent_digits_number):
    max_rows_product = 0

    for row in m:
        max_rows_product = max(max_rows_product, max_product(row, adjacent_digits_number))

    return max_rows_product


def matrix_cols_max_product(m, adjacent_digits_number):
    cols_num = len(m[0])
    max_cols_product = 0

    for col in range(cols_num):
        column = []
        for row in m:
            column.append(row[col])

        max_cols_product = max(max_cols_product, max_product(column, adjacent_digits_number))

    return max_cols_product


def square_matrix_down_left_diagonals_max_product(m, adjacent_digits_number, matrix_len):
    max_down_left_diagonals_product = 0

    for i in range(matrix_len - adjacent_digits_number + 1):
        k = i
        diagonal_a = []
        diagonal_b = []

        for j in range(matrix_len - i):
            diagonal_a.append(m[k][j])
            diagonal_b.append(m[j][k])
            k += 1

        a_product = max_product(diagonal_a, adjacent_digits_number)
        b_product = max_product(diagonal_b, adjacent_digits_number)

        max_down_left_diagonals_product = max_of_three(max_down_left_diagonals_product, a_product, b_product)

    return max_down_left_diagonals_product


def square_matrix_up_right_diagonals_max_product(m, adjacent_digits_number, matrix_len):
    max_up_right_diagonals_product = 0

    for i in range(matrix_len - adjacent_digits_number + 1):
        k = matrix_len - 1
        j = k - i
        diagonal_a = []
        diagonal_b = []

        for n in range(matrix_len - i):
            diagonal_a.append(m[k][n + i])
            diagonal_b.append(m[j][n])
            k -= 1
            j -= 1

        a_product = max_product(diagonal_a, adjacent_digits_number)
        b_product = max_product(diagonal_b, adjacent_digits_number)

        max_up_right_diagonals_product = max_of_three(max_up_right_diagonals_product, a_product, b_product)

    return max_up_right_diagonals_product


def square_matrix_diagonals_max_product(m, adjacent_digits_number):
    matrix_length = len(m)

    max_down_left = square_matrix_down_left_diagonals_max_product(m, adjacent_digits_number, matrix_length)
    max_up_right = square_matrix_up_right_diagonals_max_product(m, adjacent_digits_number, matrix_length)

    return max(max_down_left, max_up_right)


def square_matrix_max_adjacent_product(matrix, adjacent_digits_number):
    max_product_of_rows = matrix_rows_max_product(matrix, adjacent_digits_number)
    max_product_of_cols = matrix_cols_max_product(matrix, adjacent_digits_number)
    max_product_of_diagonals = square_matrix_diagonals_max_product(matrix, adjacent_digits_number)

    return max_of_three(max_product_of_rows, max_product_of_cols, max_product_of_diagonals)


print(square_matrix_max_adjacent_product(create_matrix_from_file("file.txt"), 4))









"""     problem 12        """


import math


def is_prime(num, primes):
    for p in primes:
        if num % p == 0:
            return False
    return True


def get_primes(primes_bound):
    primes = [2]
    current_prime = 3
    bound = int(math.sqrt(primes_bound))

    while current_prime < bound:
        if is_prime(current_prime, primes):
            primes.append(current_prime)

        current_prime += 2

    return primes


def triangle_num(n):
    return int((n * (n + 1)) / 2)


def divisors_number(n, primes):
    divs = 1
    cur = n

    for p in primes:
        if p > n:
            break

        if cur % p != 0:
            continue
        else:
            power = 1
            cur /= p

        while cur % p == 0:
            power += 1
            cur /= p

        divs *= (power + 1)

    return divs


def first_triangle_num_with_n_divisors(n, primes_bound):
    primes = get_primes(primes_bound)
    first_triangle = 0
    i = 1

    while first_triangle == 0:
        current_triangle = triangle_num(i)
        if divisors_number(current_triangle, primes) > n:
            first_triangle = current_triangle

        i += 1

    return first_triangle


print(first_triangle_num_with_n_divisors(500, 100000))









"""     problem 13        """


def find_sum_first_n_digits(path, first_digits_num):
    file = open(path)
    numbers_sum = 0

    for num in file:
        numbers_sum += int(num)

    return str(numbers_sum)[:first_digits_num]


print(find_sum_first_n_digits("file.txt", 10))









"""     problem 14        """


def chain_length(n):
    chain_len = 0
    m = n

    while m > 1:
        if m % 2 != 0:
            m = m + m + m + 1
        else:
            m = m >> 1

        chain_len += 1

    return chain_len


def max_chain_length_head(bound):
    chains = []

    for i in range(bound):
        chains.append(chain_length(i))

    return chains.index(max(chains))


print(max_chain_length_head(1000000))









"""     problem 15        """


def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)


def choose(n, k):
    return int(factorial(n) / (factorial(k) * factorial(n - k)))


print(choose(40, 20))









"""     problem 16        """


def find_digits_sum(base, exponent):
    power = str(base ** exponent)
    digits_sum = 0

    for digit in power:
        digits_sum += int(digit)

    return digits_sum


print(find_digits_sum(2, 1000))









"""     problem 17        """


hundreds = ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
teens = ["eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"]
tens = ["ten", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"]
singles = ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
thousand = "onethousand"
str = ""

for i in range(1, 1000):
    j = i % 100

    if i > 99:
        str += hundreds[(i // 100) - 1] + "hundred"
        if j != 0:
            str += "and"

    if j > 19:
        str += tens[(j // 10) - 1]
        if (j % 10) - 1 > -1:
            str += singles[(j % 10) - 1]
    elif j == 10:
        str += tens[0]
    elif j > 10 and j < 20:
        str += teens[(j % 10) - 1]
    else:
        if j > 0:
            str += singles[j - 1]

str += thousand

print(len(str))









"""     problem 18        """


def create_matrix(path):
    file = open(path, "r")

    matrix = []

    for line in file:
        line = (line[:-1]).split(" ")
        new_line = []
        for str in line:
            new_line.append(int(str))
        matrix.append(new_line)

    return matrix


def calculate_max_route_sum(path):
    matrix = create_matrix(path)
    cur_row = 0

    for row in matrix:
        if cur_row != 0:
            for i in range(len(row)):
                if i == 0:
                    row[i] += matrix[cur_row - 1][0]
                elif i == len(row) - 1:
                    row[i] += matrix[cur_row - 1][len(row) - 2]
                else:
                    row[i] += max(matrix[cur_row - 1][i], matrix[cur_row - 1][i - 1])

        cur_row += 1

    return max(matrix[len(matrix) - 1])


print(calculate_max_route_sum("file.txt"))









